"""Global configuration management for odoodev.

Handles loading/saving of ~/.config/odoodev/config.yaml with defaults
for base directory, database credentials, and active versions.
"""

from __future__ import annotations

import os
from dataclasses import dataclass, field
from pathlib import Path

import yaml

DEFAULT_BASE_DIR = "~/gitbase"
DEFAULT_DB_USER = "ownerp"
DEFAULT_DB_PASSWORD = "CHANGE_AT_FIRST"
DEFAULT_ACTIVE_VERSIONS = ["16", "17", "18", "19"]

# Module-level cache to avoid repeated disk reads
_cached_config: GlobalConfig | None = None


@dataclass(frozen=True)
class DatabaseConfig:
    """Database credential configuration."""

    user: str = DEFAULT_DB_USER
    password: str = DEFAULT_DB_PASSWORD


@dataclass(frozen=True)
class GlobalConfig:
    """Global odoodev configuration stored in ~/.config/odoodev/config.yaml."""

    base_dir: str = DEFAULT_BASE_DIR
    database: DatabaseConfig = field(default_factory=DatabaseConfig)
    active_versions: list[str] = field(default_factory=lambda: list(DEFAULT_ACTIVE_VERSIONS))

    @property
    def base_dir_expanded(self) -> str:
        """Return base_dir with ~ expanded to full path."""
        return os.path.expanduser(self.base_dir)


def get_config_dir() -> Path:
    """Return the odoodev configuration directory."""
    return Path.home() / ".config" / "odoodev"


def get_config_path() -> Path:
    """Return the path to the global config.yaml."""
    return get_config_dir() / "config.yaml"


def config_exists() -> bool:
    """Check if a global config.yaml exists."""
    return get_config_path().is_file()


def load_global_config() -> GlobalConfig:
    """Load global configuration from config.yaml.

    Returns defaults if no config file exists. Uses module-level cache
    to avoid repeated disk reads within the same process.

    Returns:
        GlobalConfig with loaded or default values.
    """
    global _cached_config
    if _cached_config is not None:
        return _cached_config

    config_path = get_config_path()
    if not config_path.is_file():
        _cached_config = GlobalConfig()
        return _cached_config

    with open(config_path, encoding="utf-8") as f:
        data = yaml.safe_load(f)

    if not data or not isinstance(data, dict):
        _cached_config = GlobalConfig()
        return _cached_config

    db_data = data.get("database", {})
    db_config = DatabaseConfig(
        user=db_data.get("user", DEFAULT_DB_USER),
        password=db_data.get("password", DEFAULT_DB_PASSWORD),
    )

    _cached_config = GlobalConfig(
        base_dir=data.get("base_dir", DEFAULT_BASE_DIR),
        database=db_config,
        active_versions=data.get("active_versions", list(DEFAULT_ACTIVE_VERSIONS)),
    )
    return _cached_config


def save_global_config(config: GlobalConfig) -> Path:
    """Save global configuration to config.yaml.

    Creates the config directory if it doesn't exist.

    Args:
        config: GlobalConfig to persist.

    Returns:
        Path to the saved config file.
    """
    global _cached_config
    config_path = get_config_path()
    config_path.parent.mkdir(parents=True, exist_ok=True)

    data = {
        "base_dir": config.base_dir,
        "database": {
            "user": config.database.user,
            "password": config.database.password,
        },
        "active_versions": config.active_versions,
    }

    with open(config_path, "w", encoding="utf-8") as f:
        f.write("# Generated by: odoodev setup\n")
        yaml.dump(data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)

    # Update cache
    _cached_config = config
    return config_path


def clear_config_cache() -> None:
    """Clear the module-level config cache. Useful for testing."""
    global _cached_config
    _cached_config = None
